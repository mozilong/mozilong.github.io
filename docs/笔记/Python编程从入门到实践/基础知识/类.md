## 前言（阅读）
*面向对象编程是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。根据类来创建对象被称为实例化，这让你能够使用类的实例。在本章中，你将编写一些类并创建其实例。你将指定可在实例中存储什么信息，定义可对这些实例执行哪些操作。你还将编写一些类来扩展既有类的功能，让相似的类能够高效地共享代码。你将把自己编写的类存储在模块中，并在自己的程序文件中导入其他程序员编写的类。理解面向对象编程有助于你像程序员那样看世界，还可以帮助你真正明白自己编写的代码：不仅是各行代码的作用，还有代码背后更宏大的概念。了解类背后的概念可培养逻辑思维，让你能够通过编写程序来解决遇到的几乎任何问题。随着面临的挑战日益严峻，类还能让你以及与你合作的其他程序员的生活更轻松。如果你与其他程序员基于同样的逻辑来编写代码，你们就能明白对方所做的工作；你编写的程序将能被众多合作者所理解，每个人都能事半功倍。*
## 创建和使用类
使用类几乎可以模拟任何东西，下面编写一个表示小狗的简单类Dog,它表示的不是特定的小狗，而是任何小狗，小狗大多数都具备年龄和姓名，所以这个类将包含它们
### 创建Dog类
```python
class Dog():# 定义一个叫Dog的类
	"一次模拟小狗的简单尝试"
	def _init_(self,name,age):# _init_方法是一种特殊的方法，每当你根据Dog类创建实例时，会被执行
		"初始化属性name和age"
		self.name = name # 这里定义的两个变量都有self前缀，带有前缀的变量可供类中的所有方法使用
		self.age = age
	def sit(self)# 这里定义了两个方法，因为不需要额外的信息，所以只有一个形参self
		"模拟小狗被命令时蹲下"
		print(self.name.title() + "is now sitting")
	def roll_over(self):
		"模拟小狗被命令时打滚"
		print(self.name.title()+"rolled over!")
```
* 们将方法__init__()定义成了包含三个形参：self、name和age。在这个方法的定义中，形参self必不可少，还必须位于其他形参的前面，因为Python调用这个__init__()方法来创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建Dog实例时，Python将调用Dog类的方法__init__()。我们将通过实参向Dog()传递名字和年龄；self会自动传递，因此我们不需要传递它。每当我们根据Dog类创建实例时，都只需给最后两个形参（name和age）提供值
* 以self为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。self.name = name获取存储在形参name中的值，并将其存储到变量name中，然后该变量被关联到当前创建的实例。self.age = age的作用与此类似
### 根据类创建实例
```python
class Dog():# 定义一个叫Dog的类
	"一次模拟小狗的简单尝试"
	def _init_(self,name,age):# _init_方法是一种特殊的方法，每当你根据Dog类创建实例时，会被执行
		"初始化属性name和age"
		self.name = name # 这里定义的两个变量都有self前缀，带有前缀的变量可供类中的所有方法使用
		self.age = age
	def sit(self)# 这里定义了两个方法，因为不需要额外的信息，所以只有一个形参self
		"模拟小狗被命令时蹲下"
		print(self.name.title() + "is now sitting")
	def roll_over(self):
		"模拟小狗被命令时打滚"
		print(self.name.title()+"rolled over!")
# 下面来创建一个表示特定小狗的实例

my_dog = Dog('willie', 6)# 在这里我们让Python创建了一个姓名为Willie，年龄为6的小狗，方法
#_init_虽然没有return语句，但Python会自动返回一个表示这条小狗的实例，这个实例被我存到了my-dog中
print("My dog's name is " + my_dog.name.title() + ".")# 我们编写了my_dog.name来访问my_dog的属性，name的值
print("My dog is " + str(my_dog.age) + " years old.")# 我们用同样的方式来获取age的值
```
#### 访问属性
要访问实例的属性，可以用句点表示法，类似上方代码中的print中的`my_dog.name`，句号表示法在Python中很常用，这种语法演示了Python如何获取属性的值
#### 调用方法
根据Dog类创建实例后，就可以使用句点表示法来调用Dog类中定义的任何方法。下面来让小狗蹲下和打滚
```python
my_dog.sit()
my_dog.roll_over()
```
要调用方法可以指定实例的名称，这里是my_dog，还有要调用的方法，用句点分隔他们，遇到代码my_dog.sit()时，Python在类Dog中查找方法sit()并运行其代码。Python以同样的方式解读代码my_dog.roll_over()。
#### 创建多个实例
可以根据需求根据类创建任意数量的实例
```python
my_dog = Dog('willie', 6)
your_dog = Dog('lucy', 3) 
print("My dog's name is " + my_dog.name.title() + ".") 
print("My dog is " + str(my_dog.age) + " years old.")
my_dog.sit()

print("\nYour dog's name is " + your_dog.name.title() + ".") 
print("Your dog is " + str(your_dog.age) + " years old.")
your_dog.sit()
```
在这个实例中我们创建了两条小狗，一条willie和一条lucy，每条小狗都是一个独立的实例，有自己的一组属性
就算我们给第二条小狗指定同样的名字和年龄，Python依然会根据Dog类创建另一个实例。你可按需求根据一个类创建任意数量的实例，条件是将每个实例都存储在不同的变量中，或占用列表或字典的不同位置
##### 动手试一试
```
9-1 餐馆：创建一个名为Restaurant的类，其方法__init__()设置两个属性：restaurant_name和
cuisine_type。创建一个名为describe_restaurant()的方法和一个名为open_restaurant()的方法，
其中前者打印前述两项信息，而后者打印一条消息，指出餐馆正在营业。根据这个类创建一个名为
restaurant的实例，分别打印其两个属性，再调用前述两个方法。
9-2 三家餐馆：根据你为完成练习9-1而编写的类创建三个实例，并对每个实例调用方法describe_restaurant()。
9-3 用户：创建一个名为User的类，其中包含属性first_name和last_name，还有用户简介通常会存储的
其他几个属性。在类User中定义一个名为describe_user()的方法，它打印用户信息摘要；再定义一个名
为greet_user()的方法，它向用户发出个性化的问候。
创建多个表示不同用户的实例，并对每个实例都调用上述两个方法。
```
## 使用类和实例
可以使用类来模拟现实世界中的很多情景，类编写好后，你的大部分时间都会花在根据类所创建的实例上。你需要执行的一个重要任务是修改实例的属性。你可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。
### car类
下面将编写一个car类
```python
class Car():
	"一次模拟汽车的简单尝试"
	def _init_(self,make,model,year):
		"初始化描述汽车的属性"
		self.make = make
		self.model = model
		self.year = year
	def get_descriptive_name(self):# 我们定义了一个名为get_descriptive_name()的方法，它使用属性year、make和model创建一个对汽车进行描述的字符串
		"返回整体性的描述信息"
		long_name = str(self.year) + ' ' + self.make + ' ' +self.model
		return long_name.title()
my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())# 我们调用了方法get_descriptive_name()，指出我们拥有的是一辆什么样的汽车
```
### 给属性指定默认值
类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法__init__()内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。
下面来添加一个叫odometer_reading的属性,初始值总为0
```python
class Car():
	"一次模拟汽车的简单尝试"
	def _init_(self,make,model,year):
		"初始化描述汽车的属性"
		self.make = make
		self.model = model
		self.year = year
		self.odometer_reading = 0
	def get_descriptive_name(self):# 我们定义了一个名为get_descriptive_name()的方法，它使用属性year、make和model创建一个对汽车进行描述的字符串
		"返回整体性的描述信息"
		long_name = str(self.year) + ' ' + self.make + ' ' +self.model
		return long_name.title()
	def read_odometer(self)
		"打印一条指出汽车里程的消息"
		print("This car has " + str(self.odometer_reading) + " miles on it.")
my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())# 我们调用了方法get_descriptive_name()，指出我们拥有的是一辆什么样的汽车
my_new_car.read_odometer()
```
默认值还有一种方法
```python
class Car():
	"一次模拟汽车的简单尝试"
	def _init_(self,make,model,year,odometer_reading = 0):
# 这种方法如果不输入的话就会默认为0，如果输入的话就会按照输入的值
		"初始化描述汽车的属性"
		self.make = make
		self.model = model
		self.year = year
	def get_descriptive_name(self):# 我们定义了一个名为get_descriptive_name()的方法，它使用属性year、make和model创建一个对汽车进行描述的字符串
		"返回整体性的描述信息"
		long_name = str(self.year) + ' ' + self.make + ' ' +self.model
		return long_name.title()
	def read_odometer(self)
		"打印一条指出汽车里程的消息"
		print("This car has " + str(self.odometer_reading) + " miles on it.")
my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())# 我们调用了方法get_descriptive_name()，指出我们拥有的是一辆什么样的汽车
my_new_car.read_odometer()
```
### 修改属性的值
有三种方法可以修改属性的值
#### 直接修改属性的值
最简单的方法就是通过实例直接访问它
```python
```python
class Car():
	"一次模拟汽车的简单尝试"
	def _init_(self,make,model,year):
		"初始化描述汽车的属性"
		self.make = make
		self.model = model
		self.year = year
		self.odometer_reading = 0
	def get_descriptive_name(self):# 我们定义了一个名为get_descriptive_name()的方法，它使用属性year、make和model创建一个对汽车进行描述的字符串
		"返回整体性的描述信息"
		long_name = str(self.year) + ' ' + self.make + ' ' +self.model
		return long_name.title()
	def read_odometer(self)
		"打印一条指出汽车里程的消息"
		print("This car has " + str(self.odometer_reading) + " miles on it.")
my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())# 我们调用了方法get_descriptive_name()，指出我们拥有的是一辆什么样的汽车
my_new_car.read_odometer()

# 直接修改属性的值
my_new_car.odometer_reading = 23 # 这里我们使用句点表示法直接访问并设置汽车的属性odometer_reading，
#这行代码让Python在实例my_new_car中找到属性odometer_reading，并将该属性的值设置为23：
my_new_car.read_odometer()
```
### 通过方法修改属性的值
如果有替你更新属性的方法，将大有裨益。这样，你就无需直接访问属性，而可将值传递给一个方法，由它在内部进行更新。
```python
class Car():
	"一次模拟汽车的简单尝试"
	def _init_(self,make,model,year):
		"初始化描述汽车的属性"
		self.make = make
		self.model = model
		self.year = year
		self.odometer_reading = 0
	def get_descriptive_name(self):# 我们定义了一个名为get_descriptive_name()的方法，它使用属性year、make和model创建一个对汽车进行描述的字符串
		"返回整体性的描述信息"
		long_name = str(self.year) + ' ' + self.make + ' ' +self.model
		return long_name.title()
	def read_odometer(self)
		"打印一条指出汽车里程的消息"
		print("This car has " + str(self.odometer_reading) + " miles on it.")
	def update_odometer(self,mileage):# 这个方法接受一个里程值，并将其存储在self.odometer_reading中
		self.ofometer_reading = mileage
my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())# 我们调用了方法get_descriptive_name()，指出我们拥有的是一辆什么样的汽车
my_new_car.read_odometer()

my_new_car.update_odometer(23)# 在此处我们调用了update_odometer()方法，并提供了实参23
my_new_car.read_odometer()
```
可对方法update_odometer()进行扩展，使其在修改里程表读数时做些额外的工作。下面来添加一些逻辑，禁止任何人将里程表读数往回调
```python
class Car():
	"一次模拟汽车的简单尝试"
	def _init_(self,make,model,year):
		"初始化描述汽车的属性"
		self.make = make
		self.model = model
		self.year = year
		self.odometer_reading = 0
	def get_descriptive_name(self):# 我们定义了一个名为get_descriptive_name()的方法，它使用属性year、make和model创建一个对汽车进行描述的字符串
		"返回整体性的描述信息"
		long_name = str(self.year) + ' ' + self.make + ' ' +self.model
		return long_name.title()
	def read_odometer(self)
		"打印一条指出汽车里程的消息"
		print("This car has " + str(self.odometer_reading) + " miles on it.")
	def update_odometer(self,mileage):# 这个方法接受一个里程值，并将其存储在self.odometer_reading中
		"通过if判断输入值的大小来做到禁止将里程往回调"
		if mileage >= self.odometer_reading: 
			self.odometer_reading = mileage 
		else: 
			print("You can't roll back an odometer!"
		
my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())# 我们调用了方法get_descriptive_name()，指出我们拥有的是一辆什么样的汽车
my_new_car.read_odometer()

my_new_car.update_odometer(23)# 在此处我们调用了update_odometer()方法，并提供了实参23
my_new_car.read_odometer()
```
### 通过方法对属性的值进行递增
有时候需要将属性值递增特定的量，而不是将其设置为全新的值。假设我们购买了一辆二手车，且从购买到登记期间增加了100英里的里程，下面的方法让我们能够传递这个增量，并相应地增加里程表读数：
```python
class Car():#省略了，实在不想写了，和上边的一样
	def increment_odometer(self, miles):# 增加了新的方法
	"""将里程表读数增加指定的量"""
	self.odometer_reading += miles 
my_used_car = Car('subaru', 'outback', 2013)#我们创建了一辆二手车
print(my_used_car.get_descriptive_name()) 
my_used_car.update_odometer(23500)# 我们调用了方法update——odometer()传入23500
my_used_car.read_odometer() 
my_used_car.increment_odometer(100)# 我们调用incremernt_odometer方法并传入100
my_used_car.read_odometer()
```
##### 动手试一试
```
9-4 就餐人数：在为完成练习9-1而编写的程序中，添加一个名为number_served的属性，并将其默认值设置为0。根
据这个类创建一个名为restaurant的实例；打印有多少人在这家餐馆就餐过，然后修改这个值并再次打印它。
添加一个名为set_number_served()的方法，它让你能够设置就餐人数。调用这个方法并向它传递一个值，然后再次
打印这个值。
添加一个名为increment_number_served()的方法，它让你能够将就餐人数递增。调用这个方法并向它传递一个这样
的值：你认为这家餐馆每天可能接待的就餐人数。
9-5 尝试登录次数：在为完成练习9-3而编写的User类中，添加一个名为login_attempts 的属性。编写一个名为
increment_login_attempts()的方法，它将属性login_attempts的值加1。再编写一个名为
reset_login_attempts()的方法，它将属性login_attempts的值重置为0。根据User类创建一个实例，再调用方
法increment_login_attempts()多次。打印属性login_attempts的值，确认它被正确地递增；然后，调用方法
reset_login_attempts()，并再次打印属性login_attempts的值，确认它被重置为0。
```